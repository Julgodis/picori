//! Deserialize and Serialize Dolphin Executables (`.dol` files).
//!
//! # Deserialize
//!
//! Deserialization can be done by calling [`parse`].
//!
//! ## Examples
//!
//! This example deserializes a `.dol` file. Open the `.dol` file and pass
//! it to [`parse`] to deserialize it. On error,
//! [`parse`] returns a [Error][`crate::Error`]. Otherwise, you have now
//! access to all the information contained in the inside the `.dol` file via
//! [`Dol`].
//!
//! ```no_run
//! # use std::fs::File;
//! # use picori::Result;
//! fn main() -> Result<()> {
//!     let mut file = File::open("main.dol")?;
//!     let dol = picori::file::dol::parse(&mut file)?;
//!     println!("entry point: {:#08x}", dol.entry_point());
//!     Ok(())
//! }
//! ```
//!
//! # Serialize
//!
//! TODO: Write this section.

use std::io::{Cursor, SeekFrom};

use crate::error::DeserializeProblem::*;
use crate::helper::alignment::AlignPowerOfTwo;
use crate::helper::take_last_n::TakeLastN;
use crate::helper::{ensure, Deserializer, Seeker};
use crate::Result;

/// `Dolphin Executable` header (native endian).
#[derive(Debug, Clone)]
pub struct Header {
    /// Offset of the text sections.
    pub text_offset: [u32; 7], // 0x00

    /// Offset of the data sections.
    pub data_offset: [u32; 11], // 0x1C

    /// Address of the text sections.
    pub text_address: [u32; 7], // 0x48

    /// Address of the data sections.
    pub data_address: [u32; 11], // 0x64

    /// Size of the text sections.
    pub text_size: [u32; 7], // 0x90

    /// Size of the data sections.
    pub data_size: [u32; 11], // 0xAC

    /// BSS address.
    pub bss_address: u32, // 0xD8

    /// BSS size.
    pub bss_size: u32, // 0xDC

    /// Entry point.
    pub entry_point: u32, // 0xE0
}

/// `Dolphin Executable` section kind.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SectionKind {
    /// Text section, e.g. `.init`, `.text`, etc.
    Text,

    /// Data section, e.g. `extab_`, `extabindex_`, `.ctors`, `.dtors`,
    /// `.rodata`, `.data`, `.sdata`, `.sdata2`, etc.
    Data,

    /// BSS section, e.g., `.bss`, `.sbss`, `.sbss2`, etc.
    Bss,
}

/// `Dolphin Executable` section.
#[derive(Debug, Clone)]
pub struct Section {
    /// The kind of section this is (text, data, or bss).
    pub kind: SectionKind,

    /// The section name (e.g. `.text`, `.data`, `.rodata`, etc.), this was
    /// guessed from the type of section and order in which they appear in
    /// the `Dolphin Executable`. This is not guaranteed to be correct.
    /// [`section_name`] is responsible for guessing the name of the
    /// section.
    pub name: &'static str,

    /// The section address to load the section data at startup.
    pub address: u32,

    /// The section size in bytes.
    pub size: u32,

    /// The section size in bytes, rounded up to the nearest multiple of 32.
    pub aligned_size: u32,

    /// The section data. For `.bss` sections ([`SectionKind::Bss`]), this
    /// will be an empty vector.
    pub data: Vec<u8>,

    /// The offset of the section in the `Dolphin Executable`.
    pub offset: Option<u32>,
}

/// RomCopyInfo represents one entry in the [`__rom_copy_info`][`RomCopyInfo`]
/// symbol generated by the linker at the end of the `.init` section. It has
/// information otherwise lost in the process of converting `.elf` to `.dol`,
/// such as, the original unaligned section size. At startup the
/// [`__rom_copy_info`][`RomCopyInfo`] is used to copy each entry from the ROM
/// to the RAM.
#[derive(Debug, Copy, Clone)]
pub struct RomCopyInfo {
    /// Read Only Memory (ROM) address of the section.
    pub rom_address: u32,

    /// Random Access Memory (RAM) address of the section.
    pub ram_address: u32,

    /// The size of the section in bytes.
    pub size: u32,
}

/// List of [`RomCopyInfo`][`RomCopyInfo`] entries.
#[derive(Debug, Clone)]
pub struct RomCopyInfoList {
    /// The offset of `__rom_copy_info` in the `.init` section.
    pub offset: u32,

    /// Entries in the [`__rom_copy_info`][`RomCopyInfo`] symbol.
    pub entries: Vec<RomCopyInfo>,
}

/// BssInitInfo represents one entry in the [`__bss_init_info`][`BssInitInfo`]
/// symbol generated by the linker at the end of the `.init` section. It has
/// information otherwise lost in the process of converting `.elf` to `.dol`,
/// such as, the original unaligned section size and how many `.bss` (`.sbss`,
/// `.bss2`, etc.) sections exists. The final `.dol` file will have a single
/// `.bss` section with the size of the sum of all the `.bss` sections. At
/// startup the [`__bss_init_info`][`BssInitInfo`] is used to zero out the
/// `.bss` section in RAM.
#[derive(Debug, Copy, Clone)]
pub struct BssInitInfo {
    /// Random Access Memory (RAM) address of the section.
    pub ram_address: u32,

    /// The size of the section in bytes.
    pub size: u32,
}

/// List of [`BssInitInfo`][`BssInitInfo`] entries.
#[derive(Debug, Clone)]
pub struct BssInitInfoList {
    /// The offset of `__bss_init_info` in the `.init` section.
    pub offset: u32,

    /// Entries in the [`__bss_init_info`][`BssInitInfo`] symbol.
    pub entries: Vec<BssInitInfo>,
}

/// Deserialized `.dol` file.
#[derive(Debug, Clone)]
pub struct Dol {
    /// Header.
    pub header: Header,

    /// Data of `__rom_copy_info` symbol if it exists.
    pub rom_copy_info: Option<RomCopyInfoList>,

    /// Data of `__bss_init_info` symbol if it exists.
    pub bss_init_info: Option<BssInitInfoList>,

    /// Sections.
    pub sections: Vec<Section>,
}

impl RomCopyInfo {
    /// Deserialize [`RomCopyInfo`] from a [`ReadExtension`].
    fn from_bytes<D: Deserializer + Seeker>(reader: &mut D) -> Result<Self> {
        let rom_copy_info: Result<_> = {
            let rom_address = reader.deserialize_bu32()?;
            let ram_address = reader.deserialize_bu32()?;
            let size = reader.deserialize_bu32()?;
            Ok(RomCopyInfo {
                rom_address,
                ram_address,
                size,
            })
        };

        rom_copy_info.map_err(|_| InvalidData("invalid RomCopyInfo").into())
    }
}

impl BssInitInfo {
    /// Deserialize [`BssInitInfo`] from a [`ReadExtension`].
    fn from_bytes<D: Deserializer + Seeker>(reader: &mut D) -> Result<Self> {
        let bss_init_info: Result<_> = {
            let ram_address = reader.deserialize_bu32()?;
            let size = reader.deserialize_bu32()?;
            Ok(BssInitInfo { ram_address, size })
        };

        bss_init_info.map_err(|_| InvalidData("invalid BssInitInfo").into())
    }
}

/// Search 0x200 bytes from the end of `data` (from the `.init` section)
/// until we find all `__rom_copy_info` entries.
fn rom_copy_info_search(data: &[u8], address: u32) -> Option<RomCopyInfoList> {
    let offset = if data.len() > 0x200 {
        data.len() - 0x200
    } else {
        0
    };

    for offset in offset..data.len() {
        match RomCopyInfo::from_bytes(&mut Cursor::new(&data[offset..])) {
            Ok(rom_copy_info) => {
                if rom_copy_info.ram_address == address
                    && rom_copy_info.rom_address == address
                    && rom_copy_info.size < 0x2000000
                {
                    let rom_copy_info = data[offset..]
                        .chunks(12)
                        .map(|x| RomCopyInfo::from_bytes(&mut Cursor::new(x)))
                        .filter_map(|x| x.ok())
                        .take_while(|x| x.ram_address != 0)
                        .collect::<Vec<_>>();

                    return Some(RomCopyInfoList {
                        offset:  offset as u32,
                        entries: rom_copy_info,
                    });
                }
            },
            Err(_) => {},
        }
    }

    None
}

/// Search 0x200 bytes from the end of `data` (from the `.init` section)
/// until we find all `__bss_init_info` entries.
fn bss_init_info_search(data: &[u8], address: u32) -> Option<BssInitInfoList> {
    let offset = if data.len() > 0x200 {
        data.len() - 0x200
    } else {
        0
    };

    for offset in offset..data.len() {
        match BssInitInfo::from_bytes(&mut Cursor::new(&data[offset..])) {
            Ok(bss_init_info) => {
                if bss_init_info.ram_address == address && bss_init_info.size < 0x2000000 {
                    let bss_init_info = data[offset..]
                        .chunks(8)
                        .map(|x| BssInitInfo::from_bytes(&mut Cursor::new(x)))
                        .filter_map(|x| x.ok())
                        .take_while(|x| x.ram_address != 0)
                        .collect::<Vec<_>>();

                    return Some(BssInitInfoList {
                        offset:  offset as u32,
                        entries: bss_init_info,
                    });
                }
            },
            Err(_) => {},
        }
    }

    None
}

/// Guess section name using kind and index.
pub fn section_name(kind: SectionKind, index: usize) -> &'static str {
    match kind {
        SectionKind::Text => match index {
            0 => ".init",
            1 => ".text",
            2 => ".text.2",
            3 => ".text.3",
            4 => ".text.4",
            5 => ".text.5",
            6 => ".text.6",
            _ => unreachable!(),
        },
        SectionKind::Data => match index {
            0 => "extab_",
            1 => "extabindex_",
            2 => ".ctors",
            3 => ".dtors",
            4 => ".rodata",
            5 => ".data",
            6 => ".sdata",
            7 => ".sdata2",
            8 => ".data8",
            9 => ".data9",
            10 => ".data10",
            _ => unreachable!(),
        },
        SectionKind::Bss => match index {
            0 => ".bss",
            1 => ".sbss",
            2 => ".sbss2",
            _ => unreachable!(),
        },
    }
}

impl Section {
    fn new<D>(
        reader: &mut D,
        base: u64,
        kind: SectionKind,
        index: usize,
        offset: u32,
        address: u32,
        size: u32,
        aligned_size: u32,
    ) -> Result<Self>
    where
        D: Deserializer + Seeker,
    {
        let name = section_name(kind, index);
        let data = if size == 0 {
            Vec::new()
        } else {
            ensure!(
                size <= 0x2000000,
                InvalidData("invalid section size (too large)")
            );

            reader.seek(SeekFrom::Start(base + offset as u64))?;
            reader.read_buffer(size as usize)?
        };

        Ok(Self {
            kind,
            name,
            address,
            size,
            aligned_size,
            data,
            offset: Some(offset),
        })
    }
}

/// Deserialize [`Dol`] from a [`Deserializer`] + [`Seeker`].
///
/// # Panic
///
/// This function will not panic if the input is invalid. Any invalid input will
/// be returned as an error.
pub fn parse<D: Deserializer + Seeker>(reader: &mut D) -> Result<Dol> {
    let base = reader.position()?;

    let text_offset = reader.deserialize_bu32_array::<7>()?;
    let data_offset = reader.deserialize_bu32_array::<11>()?;
    let text_address = reader.deserialize_bu32_array::<7>()?;
    let data_address = reader.deserialize_bu32_array::<11>()?;
    let text_size = reader.deserialize_bu32_array::<7>()?;
    let data_size = reader.deserialize_bu32_array::<11>()?;
    let bss_address = reader.deserialize_bu32()?;
    let bss_size = reader.deserialize_bu32()?;
    let entry_point = reader.deserialize_bu32()?;
    let _ = reader.deserialize_bu32_array::<7>()?;

    let text_sections = text_offset
        .iter()
        .zip(text_address.iter().zip(text_size.iter()))
        .map(|(offset, (address, size))| (*offset, *address, *size));
    let text_sections = text_sections
        .enumerate()
        .map(|(i, x)| (SectionKind::Text, i, x));

    let data_sections = data_offset
        .iter()
        .zip(data_address.iter().zip(data_size.iter()))
        .map(|(offset, (address, size))| (*offset, *address, *size));
    let data_sections = data_sections
        .enumerate()
        .map(|(i, x)| (SectionKind::Data, i, x));

    let sections = text_sections.chain(data_sections);
    let mut sections: Vec<Section> = sections
        .filter(|(_, _, x)| x.1 > 0)
        .map(|(kind, index, (offset, address, size))| {
            Section::new(reader, base, kind, index, offset, address, size, size)
        })
        .collect::<Result<Vec<_>>>()?;

    // Seek to the end of the dol
    let text_sections = text_offset.iter().zip(text_size.iter());
    let data_sections = data_offset.iter().zip(data_size.iter());
    let end_of_dol = text_sections
        .chain(data_sections)
        .map(|(offset, size)| offset + size)
        .max()
        .unwrap_or(0);
    reader.seek(SeekFrom::Start(base + end_of_dol as u64))?;

    let init = sections.iter().find(|x| x.name == ".init");
    let rom_copy_info =
        init.and_then(|init| rom_copy_info_search(init.data.as_slice(), init.address));
    let bss_init_info =
        init.and_then(|init| bss_init_info_search(init.data.as_slice(), bss_address));

    for section in sections.iter_mut() {
        section.size = rom_copy_info
            .as_ref()
            .and_then(|v| v.entries.iter().find(|x| x.rom_address == section.address))
            .map_or(section.size, |x| x.size);
    }

    // If `__bss_init_info` is available we can use it to determine the size and
    // count of the `.bss` sections. Otherwise we assume that there is only one
    // `.bss` section and use the size from the header (which is probably
    // not correct).
    if let Some(bss_init_info) = &bss_init_info {
        ensure!(
            bss_init_info.entries.len() <= 3,
            InvalidData("invalid bss init info (too many sections)")
        );

        let bss_sections = bss_init_info
            .entries
            .iter()
            .enumerate()
            .map(|(index, entry)| Section {
                kind:         SectionKind::Bss,
                name:         section_name(SectionKind::Bss, index),
                address:      entry.ram_address,
                size:         entry.size,
                aligned_size: entry.size.align_next(32),
                data:         vec![],
                offset:       None,
            });
        sections.extend(bss_sections)
    } else {
        // TODO: We can probably use the data section to determine the .bss sections.
        sections.push(Section {
            kind:         SectionKind::Bss,
            name:         section_name(SectionKind::Bss, 0),
            address:      bss_address,
            size:         bss_size,
            aligned_size: bss_size,
            data:         vec![],
            offset:       None,
        });
    }

    Ok(Dol {
        header: Header {
            text_offset,
            data_offset,
            text_address,
            data_address,
            text_size,
            data_size,
            bss_address,
            bss_size,
            entry_point,
        },
        rom_copy_info,
        bss_init_info,
        sections,
    })
}

impl Dol {
    /// Returns the entry point of the DOL file. This is the address of the
    /// first instruction that will be executed. The section containing the
    /// entry point can be found using [`Dol::section_by_address`]. Entry point
    /// is also available via direct access to the [`Dol::header`].
    #[inline]
    pub fn entry_point(&self) -> u32 { self.header.entry_point }

    /// Returns an [`Some(&Section)`] if the DOL file contains a section with
    /// the given name `name` or [`None`] otherwise. Section names are not
    /// information provided by the `.dol` format, instead we assign names
    /// based on the section kind [`SectionKind`] and the index of the section.
    #[inline]
    pub fn section_by_name(&self, name: &str) -> Option<&Section> {
        self.sections.iter().find(|x| x.name == name)
    }

    /// Returns an [`Some(&Section)`] if the DOL file contains a section with
    /// that contains the given address `address` or [`None`] otherwise.
    #[inline]
    pub fn section_by_address(&self, address: u32) -> Option<&Section> {
        self.sections
            .iter()
            .find(|x| address >= x.address && address < x.address + x.size)
    }
}
